/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/youtube-search-api";
exports.ids = ["vendor-chunks/youtube-search-api"];
exports.modules = {

/***/ "(rsc)/./node_modules/youtube-search-api/index.js":
/*!**************************************************!*\
  !*** ./node_modules/youtube-search-api/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/index.js\");\nconst youtubeEndpoint = `https://www.youtube.com`;\n\nconst GetYoutubeInitData = async (url) => {\n  var initdata = await {};\n  var apiToken = await null;\n  var context = await null;\n  try {\n    const page = await axios.get(encodeURI(url));\n    const ytInitData = await page.data.split(\"var ytInitialData =\");\n    if (ytInitData && ytInitData.length > 1) {\n      const data = await ytInitData[1].split(\"</script>\")[0].slice(0, -1);\n\n      if (page.data.split(\"innertubeApiKey\").length > 0) {\n        apiToken = await page.data\n          .split(\"innertubeApiKey\")[1]\n          .trim()\n          .split(\",\")[0]\n          .split('\"')[2];\n      }\n\n      if (page.data.split(\"INNERTUBE_CONTEXT\").length > 0) {\n        context = await JSON.parse(\n          page.data.split(\"INNERTUBE_CONTEXT\")[1].trim().slice(2, -2)\n        );\n      }\n\n      initdata = await JSON.parse(data);\n      return await Promise.resolve({ initdata, apiToken, context });\n    } else {\n      console.error(\"cannot_get_init_data\");\n      return await Promise.reject(\"cannot_get_init_data\");\n    }\n  } catch (ex) {\n    await console.error(ex);\n    return await Promise.reject(ex);\n  }\n};\n\nconst GetYoutubePlayerDetail = async (url) => {\n  var initdata = await {};\n  try {\n    const page = await axios.get(encodeURI(url));\n    const ytInitData = await page.data.split(\"var ytInitialPlayerResponse =\");\n    if (ytInitData && ytInitData.length > 1) {\n      const data = await ytInitData[1].split(\"</script>\")[0].slice(0, -1);\n      initdata = await JSON.parse(data);\n      return await Promise.resolve({ ...initdata.videoDetails });\n    } else {\n      console.error(\"cannot_get_player_data\");\n      return await Promise.reject(\"cannot_get_player_data\");\n    }\n  } catch (ex) {\n    await console.error(ex);\n    return await Promise.reject(ex);\n  }\n};\n\nconst GetData = async (\n  keyword,\n  withPlaylist = false,\n  limit = 0,\n  options = []\n) => {\n  let endpoint = await `${youtubeEndpoint}/results?search_query=${keyword}`;\n  try {\n    if (Array.isArray(options) && options.length > 0) {\n      const type = options.find((z) => z.type);\n      if (typeof type == \"object\") {\n        if (typeof type.type == \"string\") {\n          switch (type.type.toLowerCase()) {\n            case \"video\":\n              endpoint = `${endpoint}&sp=EgIQAQ%3D%3D`;\n              break;\n            case \"channel\":\n              endpoint = `${endpoint}&sp=EgIQAg%3D%3D`;\n              break;\n            case \"playlist\":\n              endpoint = `${endpoint}&sp=EgIQAw%3D%3D`;\n              break;\n            case \"movie\":\n              endpoint = `${endpoint}&sp=EgIQBA%3D%3D`;\n              break;\n          }\n        }\n      }\n    }\n    const page = await GetYoutubeInitData(endpoint);\n\n    const sectionListRenderer = await page.initdata.contents\n      .twoColumnSearchResultsRenderer.primaryContents.sectionListRenderer;\n\n    let contToken = await {};\n\n    let items = await [];\n\n    await sectionListRenderer.contents.forEach((content) => {\n      if (content.continuationItemRenderer) {\n        contToken =\n          content.continuationItemRenderer.continuationEndpoint\n            .continuationCommand.token;\n      } else if (content.itemSectionRenderer) {\n        content.itemSectionRenderer.contents.forEach((item) => {\n          if (item.channelRenderer) {\n            let channelRenderer = item.channelRenderer;\n            items.push({\n              id: channelRenderer.channelId,\n              type: \"channel\",\n              thumbnail: channelRenderer.thumbnail,\n              title: channelRenderer.title.simpleText\n            });\n          } else {\n            let videoRender = item.videoRenderer;\n            let playListRender = item.playlistRenderer;\n\n            if (videoRender && videoRender.videoId) {\n              items.push(VideoRender(item));\n            }\n            if (withPlaylist) {\n              if (playListRender && playListRender.playlistId) {\n                items.push({\n                  id: playListRender.playlistId,\n                  type: \"playlist\",\n                  thumbnail: playListRender.thumbnails,\n                  title: playListRender.title.simpleText,\n                  length: playListRender.videoCount,\n                  videos: playListRender.videos,\n                  videoCount: playListRender.videoCount,\n                  isLive: false\n                });\n              }\n            }\n          }\n        });\n      }\n    });\n    const apiToken = await page.apiToken;\n    const context = await page.context;\n    const nextPageContext = await { context: context, continuation: contToken };\n    const itemsResult = limit != 0 ? items.slice(0, limit) : items;\n    return await Promise.resolve({\n      items: itemsResult,\n      nextPage: { nextPageToken: apiToken, nextPageContext: nextPageContext }\n    });\n  } catch (ex) {\n    await console.error(ex);\n    return await Promise.reject(ex);\n  }\n};\n\nconst nextPage = async (nextPage, withPlaylist = false, limit = 0) => {\n  const endpoint =\n    await `${youtubeEndpoint}/youtubei/v1/search?key=${nextPage.nextPageToken}`;\n  try {\n    const page = await axios.post(\n      encodeURI(endpoint),\n      nextPage.nextPageContext\n    );\n    const item1 =\n      page.data.onResponseReceivedCommands[0].appendContinuationItemsAction;\n    let items = [];\n    item1.continuationItems.forEach((conitem) => {\n      if (conitem.itemSectionRenderer) {\n        conitem.itemSectionRenderer.contents.forEach((item, index) => {\n          let videoRender = item.videoRenderer;\n          let playListRender = item.playlistRenderer;\n          if (videoRender && videoRender.videoId) {\n            items.push(VideoRender(item));\n          }\n          if (withPlaylist) {\n            if (playListRender && playListRender.playlistId) {\n              items.push({\n                id: playListRender.playlistId,\n                type: \"playlist\",\n                thumbnail: playListRender.thumbnails,\n                title: playListRender.title.simpleText,\n                length: playListRender.videoCount,\n                videos: GetPlaylistData(playListRender.playlistId)\n              });\n            }\n          }\n        });\n      } else if (conitem.continuationItemRenderer) {\n        nextPage.nextPageContext.continuation =\n          conitem.continuationItemRenderer.continuationEndpoint.continuationCommand.token;\n      }\n    });\n    const itemsResult = limit != 0 ? items.slice(0, limit) : items;\n    return await Promise.resolve({ items: itemsResult, nextPage: nextPage });\n  } catch (ex) {\n    await console.error(ex);\n    return await Promise.reject(ex);\n  }\n};\n\nconst GetPlaylistData = async (playlistId, limit = 0) => {\n  const endpoint = await `${youtubeEndpoint}/playlist?list=${playlistId}`;\n  try {\n    const initData = await GetYoutubeInitData(endpoint);\n    const sectionListRenderer = await initData.initdata;\n    const metadata = await sectionListRenderer.metadata;\n    if (sectionListRenderer && sectionListRenderer.contents) {\n      const videoItems = await sectionListRenderer.contents\n        .twoColumnBrowseResultsRenderer.tabs[0].tabRenderer.content\n        .sectionListRenderer.contents[0].itemSectionRenderer.contents[0]\n        .playlistVideoListRenderer.contents;\n      let items = await [];\n      await videoItems.forEach((item) => {\n        let videoRender = item.playlistVideoRenderer;\n        if (videoRender && videoRender.videoId) {\n          items.push(VideoRender(item));\n        }\n      });\n      const itemsResult = limit != 0 ? items.slice(0, limit) : items;\n      return await Promise.resolve({ items: itemsResult, metadata: metadata });\n    } else {\n      return await Promise.reject(\"invalid_playlist\");\n    }\n  } catch (ex) {\n    await console.error(ex);\n    return await Promise.reject(ex);\n  }\n};\n\nconst GetSuggestData = async (limit = 0) => {\n  const endpoint = await `${youtubeEndpoint}`;\n  try {\n    const page = await GetYoutubeInitData(endpoint);\n    const sectionListRenderer = await page.initdata.contents\n      .twoColumnBrowseResultsRenderer.tabs[0].tabRenderer.content\n      .richGridRenderer.contents;\n    let items = await [];\n    let otherItems = await [];\n    await sectionListRenderer.forEach((item) => {\n      if (item.richItemRenderer && item.richItemRenderer.content) {\n        let videoRender = item.richItemRenderer.content.videoRenderer;\n        if (videoRender && videoRender.videoId) {\n          items.push(VideoRender(item.richItemRenderer.content));\n        } else {\n          otherItems.push(videoRender);\n        }\n      }\n    });\n    const itemsResult = limit != 0 ? items.slice(0, limit) : items;\n    return await Promise.resolve({ items: itemsResult });\n  } catch (ex) {\n    await console.error(ex);\n    return await Promise.reject(ex);\n  }\n};\n\nconst GetChannelById = async (channelId) => {\n  const endpoint = await `${youtubeEndpoint}/channel/${channelId}`;\n  try {\n    const page = await GetYoutubeInitData(endpoint);\n    const tabs = page.initdata.contents.twoColumnBrowseResultsRenderer.tabs;\n    const items = tabs\n      .map((json) => {\n        if (json && json.tabRenderer) {\n          const tabRenderer = json.tabRenderer;\n          const title = tabRenderer.title;\n          const content = tabRenderer.content;\n          return { title, content };\n        }\n      })\n      .filter((y) => typeof y != \"undefined\");\n    return await Promise.resolve(items);\n  } catch (ex) {\n    return await Promise.reject(ex);\n  }\n};\n\nconst GetVideoDetails = async (videoId) => {\n  const endpoint = await `${youtubeEndpoint}/watch?v=${videoId}`;\n  try {\n    const page = await GetYoutubeInitData(endpoint);\n    const playerData = await GetYoutubePlayerDetail(endpoint);\n\n    const result = await page.initdata.contents.twoColumnWatchNextResults;\n    const firstContent = await result.results.results.contents[0]\n      .videoPrimaryInfoRenderer;\n    const secondContent = await result.results.results.contents[1]\n      .videoSecondaryInfoRenderer;\n    const res = await {\n      id: playerData.videoId,\n      title: firstContent.title.runs[0].text,\n      thumbnail: playerData.thumbnail,\n      isLive: firstContent.viewCount.videoViewCountRenderer.hasOwnProperty(\n        \"isLive\"\n      )\n        ? firstContent.viewCount.videoViewCountRenderer.isLive\n        : false,\n      channel:\n        playerData.author ||\n        secondContent.owner.videoOwnerRenderer.title.runs[0].text,\n      channelId: playerData.channelId,\n      description: playerData.shortDescription,\n      keywords: playerData.keywords,\n      suggestion: result.secondaryResults.secondaryResults.results\n        .filter((y) => y.hasOwnProperty(\"compactVideoRenderer\"))\n        .map((x) => compactVideoRenderer(x))\n    };\n\n    return await Promise.resolve(res);\n  } catch (ex) {\n    return await Promise.reject(ex);\n  }\n};\n\nconst VideoRender = (json) => {\n  try {\n    if (json && (json.videoRenderer || json.playlistVideoRenderer)) {\n      let videoRenderer = null;\n      if (json.videoRenderer) {\n        videoRenderer = json.videoRenderer;\n      } else if (json.playlistVideoRenderer) {\n        videoRenderer = json.playlistVideoRenderer;\n      }\n      var isLive = false;\n      if (\n        videoRenderer.badges &&\n        videoRenderer.badges.length > 0 &&\n        videoRenderer.badges[0].metadataBadgeRenderer &&\n        videoRenderer.badges[0].metadataBadgeRenderer.style ==\n          \"BADGE_STYLE_TYPE_LIVE_NOW\"\n      ) {\n        isLive = true;\n      }\n      if (videoRenderer.thumbnailOverlays) {\n        videoRenderer.thumbnailOverlays.forEach((item) => {\n          if (\n            item.thumbnailOverlayTimeStatusRenderer &&\n            item.thumbnailOverlayTimeStatusRenderer.style &&\n            item.thumbnailOverlayTimeStatusRenderer.style == \"LIVE\"\n          ) {\n            isLive = true;\n          }\n        });\n      }\n      const id = videoRenderer.videoId;\n      const thumbnail = videoRenderer.thumbnail;\n      const title = videoRenderer.title.runs[0].text;\n      const shortBylineText = videoRenderer.shortBylineText\n        ? videoRenderer.shortBylineText\n        : \"\";\n      const lengthText = videoRenderer.lengthText\n        ? videoRenderer.lengthText\n        : \"\";\n      const channelTitle =\n        videoRenderer.ownerText && videoRenderer.ownerText.runs\n          ? videoRenderer.ownerText.runs[0].text\n          : \"\";\n      return {\n        id,\n        type: \"video\",\n        thumbnail,\n        title,\n        channelTitle,\n        shortBylineText,\n        length: lengthText,\n        isLive\n      };\n    } else {\n      return {};\n    }\n  } catch (ex) {\n    throw ex;\n  }\n};\n\nconst compactVideoRenderer = (json) => {\n  const compactVideoRendererJson = json.compactVideoRenderer;\n\n  var isLive = false;\n  if (\n    compactVideoRendererJson.badges &&\n    compactVideoRendererJson.badges.length > 0 &&\n    compactVideoRendererJson.badges[0].metadataBadgeRenderer &&\n    compactVideoRendererJson.badges[0].metadataBadgeRenderer.style ==\n      \"BADGE_STYLE_TYPE_LIVE_NOW\"\n  ) {\n    isLive = true;\n  }\n  const result = {\n    id: compactVideoRendererJson.videoId,\n    type: \"video\",\n    thumbnail: compactVideoRendererJson.thumbnail.thumbnails,\n    title: compactVideoRendererJson.title.simpleText,\n    channelTitle: compactVideoRendererJson.shortBylineText.runs[0].text,\n    shortBylineText: compactVideoRendererJson.shortBylineText.runs[0].text,\n    length: compactVideoRendererJson.lengthText,\n    isLive\n  };\n  return result;\n};\n\nconst GetShortVideo = async () => {\n  const page = await GetYoutubeInitData(youtubeEndpoint);\n  const shortResult =\n    await page.initdata.contents.twoColumnBrowseResultsRenderer.tabs[0].tabRenderer.content.richGridRenderer.contents\n      .filter((x) => {\n        return x.richSectionRenderer;\n      })\n      .map((z) => z.richSectionRenderer.content)\n      .filter((y) => y.richShelfRenderer)\n      .map((u) => u.richShelfRenderer)\n      .find((i) => i.title.runs[0].text == \"Shorts\");\n  const res = await shortResult.contents\n    .map((z) => z.richItemRenderer)\n    .map((y) => y.content.reelItemRenderer);\n  return await res.map((json) => ({\n    id: json.videoId,\n    type: \"reel\",\n    thumbnail: json.thumbnail.thumbnails[0],\n    title: json.headline.simpleText,\n    inlinePlaybackEndpoint: json.inlinePlaybackEndpoint || {}\n  }));\n};\n\nexports.GetListByKeyword = GetData;\nexports.NextPage = nextPage;\nexports.GetPlaylistData = GetPlaylistData;\nexports.GetSuggestData = GetSuggestData;\nexports.GetChannelById = GetChannelById;\nexports.GetVideoDetails = GetVideoDetails;\nexports.GetShortVideo = GetShortVideo;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveW91dHViZS1zZWFyY2gtYXBpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxrREFBTztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyw2QkFBNkI7QUFDbEUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0Isd0JBQXdCLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0IsMEJBQTBCLHVCQUF1QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsd0NBQXdDO0FBQzNFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixnQkFBZ0IsaUJBQWlCLFdBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EscUNBQXFDLHdDQUF3QztBQUM3RSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGdCQUFnQixXQUFXLFVBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGdCQUFnQixXQUFXLFFBQVE7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsd0JBQXdCO0FBQ3hCLGdCQUFnQjtBQUNoQix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3lvdXR1YmUtc2VhcmNoLWFwaS9pbmRleC5qcz8xYjdjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xuY29uc3QgeW91dHViZUVuZHBvaW50ID0gYGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tYDtcblxuY29uc3QgR2V0WW91dHViZUluaXREYXRhID0gYXN5bmMgKHVybCkgPT4ge1xuICB2YXIgaW5pdGRhdGEgPSBhd2FpdCB7fTtcbiAgdmFyIGFwaVRva2VuID0gYXdhaXQgbnVsbDtcbiAgdmFyIGNvbnRleHQgPSBhd2FpdCBudWxsO1xuICB0cnkge1xuICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBheGlvcy5nZXQoZW5jb2RlVVJJKHVybCkpO1xuICAgIGNvbnN0IHl0SW5pdERhdGEgPSBhd2FpdCBwYWdlLmRhdGEuc3BsaXQoXCJ2YXIgeXRJbml0aWFsRGF0YSA9XCIpO1xuICAgIGlmICh5dEluaXREYXRhICYmIHl0SW5pdERhdGEubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHl0SW5pdERhdGFbMV0uc3BsaXQoXCI8L3NjcmlwdD5cIilbMF0uc2xpY2UoMCwgLTEpO1xuXG4gICAgICBpZiAocGFnZS5kYXRhLnNwbGl0KFwiaW5uZXJ0dWJlQXBpS2V5XCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXBpVG9rZW4gPSBhd2FpdCBwYWdlLmRhdGFcbiAgICAgICAgICAuc3BsaXQoXCJpbm5lcnR1YmVBcGlLZXlcIilbMV1cbiAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgLnNwbGl0KFwiLFwiKVswXVxuICAgICAgICAgIC5zcGxpdCgnXCInKVsyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZ2UuZGF0YS5zcGxpdChcIklOTkVSVFVCRV9DT05URVhUXCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29udGV4dCA9IGF3YWl0IEpTT04ucGFyc2UoXG4gICAgICAgICAgcGFnZS5kYXRhLnNwbGl0KFwiSU5ORVJUVUJFX0NPTlRFWFRcIilbMV0udHJpbSgpLnNsaWNlKDIsIC0yKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpbml0ZGF0YSA9IGF3YWl0IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHsgaW5pdGRhdGEsIGFwaVRva2VuLCBjb250ZXh0IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiY2Fubm90X2dldF9pbml0X2RhdGFcIik7XG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZWplY3QoXCJjYW5ub3RfZ2V0X2luaXRfZGF0YVwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgYXdhaXQgY29uc29sZS5lcnJvcihleCk7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVqZWN0KGV4KTtcbiAgfVxufTtcblxuY29uc3QgR2V0WW91dHViZVBsYXllckRldGFpbCA9IGFzeW5jICh1cmwpID0+IHtcbiAgdmFyIGluaXRkYXRhID0gYXdhaXQge307XG4gIHRyeSB7XG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IGF4aW9zLmdldChlbmNvZGVVUkkodXJsKSk7XG4gICAgY29uc3QgeXRJbml0RGF0YSA9IGF3YWl0IHBhZ2UuZGF0YS5zcGxpdChcInZhciB5dEluaXRpYWxQbGF5ZXJSZXNwb25zZSA9XCIpO1xuICAgIGlmICh5dEluaXREYXRhICYmIHl0SW5pdERhdGEubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHl0SW5pdERhdGFbMV0uc3BsaXQoXCI8L3NjcmlwdD5cIilbMF0uc2xpY2UoMCwgLTEpO1xuICAgICAgaW5pdGRhdGEgPSBhd2FpdCBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSh7IC4uLmluaXRkYXRhLnZpZGVvRGV0YWlscyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcImNhbm5vdF9nZXRfcGxheWVyX2RhdGFcIik7XG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZWplY3QoXCJjYW5ub3RfZ2V0X3BsYXllcl9kYXRhXCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBhd2FpdCBjb25zb2xlLmVycm9yKGV4KTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZWplY3QoZXgpO1xuICB9XG59O1xuXG5jb25zdCBHZXREYXRhID0gYXN5bmMgKFxuICBrZXl3b3JkLFxuICB3aXRoUGxheWxpc3QgPSBmYWxzZSxcbiAgbGltaXQgPSAwLFxuICBvcHRpb25zID0gW11cbikgPT4ge1xuICBsZXQgZW5kcG9pbnQgPSBhd2FpdCBgJHt5b3V0dWJlRW5kcG9pbnR9L3Jlc3VsdHM/c2VhcmNoX3F1ZXJ5PSR7a2V5d29yZH1gO1xuICB0cnkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpICYmIG9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbnMuZmluZCgoeikgPT4gei50eXBlKTtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZS50eXBlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUudHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgICAgICAgICAgZW5kcG9pbnQgPSBgJHtlbmRwb2ludH0mc3A9RWdJUUFRJTNEJTNEYDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2hhbm5lbFwiOlxuICAgICAgICAgICAgICBlbmRwb2ludCA9IGAke2VuZHBvaW50fSZzcD1FZ0lRQWclM0QlM0RgO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwbGF5bGlzdFwiOlxuICAgICAgICAgICAgICBlbmRwb2ludCA9IGAke2VuZHBvaW50fSZzcD1FZ0lRQXclM0QlM0RgO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtb3ZpZVwiOlxuICAgICAgICAgICAgICBlbmRwb2ludCA9IGAke2VuZHBvaW50fSZzcD1FZ0lRQkElM0QlM0RgO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IEdldFlvdXR1YmVJbml0RGF0YShlbmRwb2ludCk7XG5cbiAgICBjb25zdCBzZWN0aW9uTGlzdFJlbmRlcmVyID0gYXdhaXQgcGFnZS5pbml0ZGF0YS5jb250ZW50c1xuICAgICAgLnR3b0NvbHVtblNlYXJjaFJlc3VsdHNSZW5kZXJlci5wcmltYXJ5Q29udGVudHMuc2VjdGlvbkxpc3RSZW5kZXJlcjtcblxuICAgIGxldCBjb250VG9rZW4gPSBhd2FpdCB7fTtcblxuICAgIGxldCBpdGVtcyA9IGF3YWl0IFtdO1xuXG4gICAgYXdhaXQgc2VjdGlvbkxpc3RSZW5kZXJlci5jb250ZW50cy5mb3JFYWNoKChjb250ZW50KSA9PiB7XG4gICAgICBpZiAoY29udGVudC5jb250aW51YXRpb25JdGVtUmVuZGVyZXIpIHtcbiAgICAgICAgY29udFRva2VuID1cbiAgICAgICAgICBjb250ZW50LmNvbnRpbnVhdGlvbkl0ZW1SZW5kZXJlci5jb250aW51YXRpb25FbmRwb2ludFxuICAgICAgICAgICAgLmNvbnRpbnVhdGlvbkNvbW1hbmQudG9rZW47XG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnQuaXRlbVNlY3Rpb25SZW5kZXJlcikge1xuICAgICAgICBjb250ZW50Lml0ZW1TZWN0aW9uUmVuZGVyZXIuY29udGVudHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtLmNoYW5uZWxSZW5kZXJlcikge1xuICAgICAgICAgICAgbGV0IGNoYW5uZWxSZW5kZXJlciA9IGl0ZW0uY2hhbm5lbFJlbmRlcmVyO1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiBjaGFubmVsUmVuZGVyZXIuY2hhbm5lbElkLFxuICAgICAgICAgICAgICB0eXBlOiBcImNoYW5uZWxcIixcbiAgICAgICAgICAgICAgdGh1bWJuYWlsOiBjaGFubmVsUmVuZGVyZXIudGh1bWJuYWlsLFxuICAgICAgICAgICAgICB0aXRsZTogY2hhbm5lbFJlbmRlcmVyLnRpdGxlLnNpbXBsZVRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgdmlkZW9SZW5kZXIgPSBpdGVtLnZpZGVvUmVuZGVyZXI7XG4gICAgICAgICAgICBsZXQgcGxheUxpc3RSZW5kZXIgPSBpdGVtLnBsYXlsaXN0UmVuZGVyZXI7XG5cbiAgICAgICAgICAgIGlmICh2aWRlb1JlbmRlciAmJiB2aWRlb1JlbmRlci52aWRlb0lkKSB7XG4gICAgICAgICAgICAgIGl0ZW1zLnB1c2goVmlkZW9SZW5kZXIoaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpdGhQbGF5bGlzdCkge1xuICAgICAgICAgICAgICBpZiAocGxheUxpc3RSZW5kZXIgJiYgcGxheUxpc3RSZW5kZXIucGxheWxpc3RJZCkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgaWQ6IHBsYXlMaXN0UmVuZGVyLnBsYXlsaXN0SWQsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInBsYXlsaXN0XCIsXG4gICAgICAgICAgICAgICAgICB0aHVtYm5haWw6IHBsYXlMaXN0UmVuZGVyLnRodW1ibmFpbHMsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogcGxheUxpc3RSZW5kZXIudGl0bGUuc2ltcGxlVGV4dCxcbiAgICAgICAgICAgICAgICAgIGxlbmd0aDogcGxheUxpc3RSZW5kZXIudmlkZW9Db3VudCxcbiAgICAgICAgICAgICAgICAgIHZpZGVvczogcGxheUxpc3RSZW5kZXIudmlkZW9zLFxuICAgICAgICAgICAgICAgICAgdmlkZW9Db3VudDogcGxheUxpc3RSZW5kZXIudmlkZW9Db3VudCxcbiAgICAgICAgICAgICAgICAgIGlzTGl2ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYXBpVG9rZW4gPSBhd2FpdCBwYWdlLmFwaVRva2VuO1xuICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBwYWdlLmNvbnRleHQ7XG4gICAgY29uc3QgbmV4dFBhZ2VDb250ZXh0ID0gYXdhaXQgeyBjb250ZXh0OiBjb250ZXh0LCBjb250aW51YXRpb246IGNvbnRUb2tlbiB9O1xuICAgIGNvbnN0IGl0ZW1zUmVzdWx0ID0gbGltaXQgIT0gMCA/IGl0ZW1zLnNsaWNlKDAsIGxpbWl0KSA6IGl0ZW1zO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgaXRlbXM6IGl0ZW1zUmVzdWx0LFxuICAgICAgbmV4dFBhZ2U6IHsgbmV4dFBhZ2VUb2tlbjogYXBpVG9rZW4sIG5leHRQYWdlQ29udGV4dDogbmV4dFBhZ2VDb250ZXh0IH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBhd2FpdCBjb25zb2xlLmVycm9yKGV4KTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZWplY3QoZXgpO1xuICB9XG59O1xuXG5jb25zdCBuZXh0UGFnZSA9IGFzeW5jIChuZXh0UGFnZSwgd2l0aFBsYXlsaXN0ID0gZmFsc2UsIGxpbWl0ID0gMCkgPT4ge1xuICBjb25zdCBlbmRwb2ludCA9XG4gICAgYXdhaXQgYCR7eW91dHViZUVuZHBvaW50fS95b3V0dWJlaS92MS9zZWFyY2g/a2V5PSR7bmV4dFBhZ2UubmV4dFBhZ2VUb2tlbn1gO1xuICB0cnkge1xuICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBheGlvcy5wb3N0KFxuICAgICAgZW5jb2RlVVJJKGVuZHBvaW50KSxcbiAgICAgIG5leHRQYWdlLm5leHRQYWdlQ29udGV4dFxuICAgICk7XG4gICAgY29uc3QgaXRlbTEgPVxuICAgICAgcGFnZS5kYXRhLm9uUmVzcG9uc2VSZWNlaXZlZENvbW1hbmRzWzBdLmFwcGVuZENvbnRpbnVhdGlvbkl0ZW1zQWN0aW9uO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuICAgIGl0ZW0xLmNvbnRpbnVhdGlvbkl0ZW1zLmZvckVhY2goKGNvbml0ZW0pID0+IHtcbiAgICAgIGlmIChjb25pdGVtLml0ZW1TZWN0aW9uUmVuZGVyZXIpIHtcbiAgICAgICAgY29uaXRlbS5pdGVtU2VjdGlvblJlbmRlcmVyLmNvbnRlbnRzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgbGV0IHZpZGVvUmVuZGVyID0gaXRlbS52aWRlb1JlbmRlcmVyO1xuICAgICAgICAgIGxldCBwbGF5TGlzdFJlbmRlciA9IGl0ZW0ucGxheWxpc3RSZW5kZXJlcjtcbiAgICAgICAgICBpZiAodmlkZW9SZW5kZXIgJiYgdmlkZW9SZW5kZXIudmlkZW9JZCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChWaWRlb1JlbmRlcihpdGVtKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aXRoUGxheWxpc3QpIHtcbiAgICAgICAgICAgIGlmIChwbGF5TGlzdFJlbmRlciAmJiBwbGF5TGlzdFJlbmRlci5wbGF5bGlzdElkKSB7XG4gICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBwbGF5TGlzdFJlbmRlci5wbGF5bGlzdElkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwicGxheWxpc3RcIixcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IHBsYXlMaXN0UmVuZGVyLnRodW1ibmFpbHMsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHBsYXlMaXN0UmVuZGVyLnRpdGxlLnNpbXBsZVRleHQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBwbGF5TGlzdFJlbmRlci52aWRlb0NvdW50LFxuICAgICAgICAgICAgICAgIHZpZGVvczogR2V0UGxheWxpc3REYXRhKHBsYXlMaXN0UmVuZGVyLnBsYXlsaXN0SWQpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbml0ZW0uY29udGludWF0aW9uSXRlbVJlbmRlcmVyKSB7XG4gICAgICAgIG5leHRQYWdlLm5leHRQYWdlQ29udGV4dC5jb250aW51YXRpb24gPVxuICAgICAgICAgIGNvbml0ZW0uY29udGludWF0aW9uSXRlbVJlbmRlcmVyLmNvbnRpbnVhdGlvbkVuZHBvaW50LmNvbnRpbnVhdGlvbkNvbW1hbmQudG9rZW47XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaXRlbXNSZXN1bHQgPSBsaW1pdCAhPSAwID8gaXRlbXMuc2xpY2UoMCwgbGltaXQpIDogaXRlbXM7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSh7IGl0ZW1zOiBpdGVtc1Jlc3VsdCwgbmV4dFBhZ2U6IG5leHRQYWdlIH0pO1xuICB9IGNhdGNoIChleCkge1xuICAgIGF3YWl0IGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJlamVjdChleCk7XG4gIH1cbn07XG5cbmNvbnN0IEdldFBsYXlsaXN0RGF0YSA9IGFzeW5jIChwbGF5bGlzdElkLCBsaW1pdCA9IDApID0+IHtcbiAgY29uc3QgZW5kcG9pbnQgPSBhd2FpdCBgJHt5b3V0dWJlRW5kcG9pbnR9L3BsYXlsaXN0P2xpc3Q9JHtwbGF5bGlzdElkfWA7XG4gIHRyeSB7XG4gICAgY29uc3QgaW5pdERhdGEgPSBhd2FpdCBHZXRZb3V0dWJlSW5pdERhdGEoZW5kcG9pbnQpO1xuICAgIGNvbnN0IHNlY3Rpb25MaXN0UmVuZGVyZXIgPSBhd2FpdCBpbml0RGF0YS5pbml0ZGF0YTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHNlY3Rpb25MaXN0UmVuZGVyZXIubWV0YWRhdGE7XG4gICAgaWYgKHNlY3Rpb25MaXN0UmVuZGVyZXIgJiYgc2VjdGlvbkxpc3RSZW5kZXJlci5jb250ZW50cykge1xuICAgICAgY29uc3QgdmlkZW9JdGVtcyA9IGF3YWl0IHNlY3Rpb25MaXN0UmVuZGVyZXIuY29udGVudHNcbiAgICAgICAgLnR3b0NvbHVtbkJyb3dzZVJlc3VsdHNSZW5kZXJlci50YWJzWzBdLnRhYlJlbmRlcmVyLmNvbnRlbnRcbiAgICAgICAgLnNlY3Rpb25MaXN0UmVuZGVyZXIuY29udGVudHNbMF0uaXRlbVNlY3Rpb25SZW5kZXJlci5jb250ZW50c1swXVxuICAgICAgICAucGxheWxpc3RWaWRlb0xpc3RSZW5kZXJlci5jb250ZW50cztcbiAgICAgIGxldCBpdGVtcyA9IGF3YWl0IFtdO1xuICAgICAgYXdhaXQgdmlkZW9JdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGxldCB2aWRlb1JlbmRlciA9IGl0ZW0ucGxheWxpc3RWaWRlb1JlbmRlcmVyO1xuICAgICAgICBpZiAodmlkZW9SZW5kZXIgJiYgdmlkZW9SZW5kZXIudmlkZW9JZCkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goVmlkZW9SZW5kZXIoaXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGl0ZW1zUmVzdWx0ID0gbGltaXQgIT0gMCA/IGl0ZW1zLnNsaWNlKDAsIGxpbWl0KSA6IGl0ZW1zO1xuICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSh7IGl0ZW1zOiBpdGVtc1Jlc3VsdCwgbWV0YWRhdGE6IG1ldGFkYXRhIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZWplY3QoXCJpbnZhbGlkX3BsYXlsaXN0XCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBhd2FpdCBjb25zb2xlLmVycm9yKGV4KTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZWplY3QoZXgpO1xuICB9XG59O1xuXG5jb25zdCBHZXRTdWdnZXN0RGF0YSA9IGFzeW5jIChsaW1pdCA9IDApID0+IHtcbiAgY29uc3QgZW5kcG9pbnQgPSBhd2FpdCBgJHt5b3V0dWJlRW5kcG9pbnR9YDtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYWdlID0gYXdhaXQgR2V0WW91dHViZUluaXREYXRhKGVuZHBvaW50KTtcbiAgICBjb25zdCBzZWN0aW9uTGlzdFJlbmRlcmVyID0gYXdhaXQgcGFnZS5pbml0ZGF0YS5jb250ZW50c1xuICAgICAgLnR3b0NvbHVtbkJyb3dzZVJlc3VsdHNSZW5kZXJlci50YWJzWzBdLnRhYlJlbmRlcmVyLmNvbnRlbnRcbiAgICAgIC5yaWNoR3JpZFJlbmRlcmVyLmNvbnRlbnRzO1xuICAgIGxldCBpdGVtcyA9IGF3YWl0IFtdO1xuICAgIGxldCBvdGhlckl0ZW1zID0gYXdhaXQgW107XG4gICAgYXdhaXQgc2VjdGlvbkxpc3RSZW5kZXJlci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbS5yaWNoSXRlbVJlbmRlcmVyICYmIGl0ZW0ucmljaEl0ZW1SZW5kZXJlci5jb250ZW50KSB7XG4gICAgICAgIGxldCB2aWRlb1JlbmRlciA9IGl0ZW0ucmljaEl0ZW1SZW5kZXJlci5jb250ZW50LnZpZGVvUmVuZGVyZXI7XG4gICAgICAgIGlmICh2aWRlb1JlbmRlciAmJiB2aWRlb1JlbmRlci52aWRlb0lkKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChWaWRlb1JlbmRlcihpdGVtLnJpY2hJdGVtUmVuZGVyZXIuY29udGVudCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVySXRlbXMucHVzaCh2aWRlb1JlbmRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBpdGVtc1Jlc3VsdCA9IGxpbWl0ICE9IDAgPyBpdGVtcy5zbGljZSgwLCBsaW1pdCkgOiBpdGVtcztcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHsgaXRlbXM6IGl0ZW1zUmVzdWx0IH0pO1xuICB9IGNhdGNoIChleCkge1xuICAgIGF3YWl0IGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJlamVjdChleCk7XG4gIH1cbn07XG5cbmNvbnN0IEdldENoYW5uZWxCeUlkID0gYXN5bmMgKGNoYW5uZWxJZCkgPT4ge1xuICBjb25zdCBlbmRwb2ludCA9IGF3YWl0IGAke3lvdXR1YmVFbmRwb2ludH0vY2hhbm5lbC8ke2NoYW5uZWxJZH1gO1xuICB0cnkge1xuICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBHZXRZb3V0dWJlSW5pdERhdGEoZW5kcG9pbnQpO1xuICAgIGNvbnN0IHRhYnMgPSBwYWdlLmluaXRkYXRhLmNvbnRlbnRzLnR3b0NvbHVtbkJyb3dzZVJlc3VsdHNSZW5kZXJlci50YWJzO1xuICAgIGNvbnN0IGl0ZW1zID0gdGFic1xuICAgICAgLm1hcCgoanNvbikgPT4ge1xuICAgICAgICBpZiAoanNvbiAmJiBqc29uLnRhYlJlbmRlcmVyKSB7XG4gICAgICAgICAgY29uc3QgdGFiUmVuZGVyZXIgPSBqc29uLnRhYlJlbmRlcmVyO1xuICAgICAgICAgIGNvbnN0IHRpdGxlID0gdGFiUmVuZGVyZXIudGl0bGU7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IHRhYlJlbmRlcmVyLmNvbnRlbnQ7XG4gICAgICAgICAgcmV0dXJuIHsgdGl0bGUsIGNvbnRlbnQgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKHkpID0+IHR5cGVvZiB5ICE9IFwidW5kZWZpbmVkXCIpO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJlc29sdmUoaXRlbXMpO1xuICB9IGNhdGNoIChleCkge1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJlamVjdChleCk7XG4gIH1cbn07XG5cbmNvbnN0IEdldFZpZGVvRGV0YWlscyA9IGFzeW5jICh2aWRlb0lkKSA9PiB7XG4gIGNvbnN0IGVuZHBvaW50ID0gYXdhaXQgYCR7eW91dHViZUVuZHBvaW50fS93YXRjaD92PSR7dmlkZW9JZH1gO1xuICB0cnkge1xuICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBHZXRZb3V0dWJlSW5pdERhdGEoZW5kcG9pbnQpO1xuICAgIGNvbnN0IHBsYXllckRhdGEgPSBhd2FpdCBHZXRZb3V0dWJlUGxheWVyRGV0YWlsKGVuZHBvaW50KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhZ2UuaW5pdGRhdGEuY29udGVudHMudHdvQ29sdW1uV2F0Y2hOZXh0UmVzdWx0cztcbiAgICBjb25zdCBmaXJzdENvbnRlbnQgPSBhd2FpdCByZXN1bHQucmVzdWx0cy5yZXN1bHRzLmNvbnRlbnRzWzBdXG4gICAgICAudmlkZW9QcmltYXJ5SW5mb1JlbmRlcmVyO1xuICAgIGNvbnN0IHNlY29uZENvbnRlbnQgPSBhd2FpdCByZXN1bHQucmVzdWx0cy5yZXN1bHRzLmNvbnRlbnRzWzFdXG4gICAgICAudmlkZW9TZWNvbmRhcnlJbmZvUmVuZGVyZXI7XG4gICAgY29uc3QgcmVzID0gYXdhaXQge1xuICAgICAgaWQ6IHBsYXllckRhdGEudmlkZW9JZCxcbiAgICAgIHRpdGxlOiBmaXJzdENvbnRlbnQudGl0bGUucnVuc1swXS50ZXh0LFxuICAgICAgdGh1bWJuYWlsOiBwbGF5ZXJEYXRhLnRodW1ibmFpbCxcbiAgICAgIGlzTGl2ZTogZmlyc3RDb250ZW50LnZpZXdDb3VudC52aWRlb1ZpZXdDb3VudFJlbmRlcmVyLmhhc093blByb3BlcnR5KFxuICAgICAgICBcImlzTGl2ZVwiXG4gICAgICApXG4gICAgICAgID8gZmlyc3RDb250ZW50LnZpZXdDb3VudC52aWRlb1ZpZXdDb3VudFJlbmRlcmVyLmlzTGl2ZVxuICAgICAgICA6IGZhbHNlLFxuICAgICAgY2hhbm5lbDpcbiAgICAgICAgcGxheWVyRGF0YS5hdXRob3IgfHxcbiAgICAgICAgc2Vjb25kQ29udGVudC5vd25lci52aWRlb093bmVyUmVuZGVyZXIudGl0bGUucnVuc1swXS50ZXh0LFxuICAgICAgY2hhbm5lbElkOiBwbGF5ZXJEYXRhLmNoYW5uZWxJZCxcbiAgICAgIGRlc2NyaXB0aW9uOiBwbGF5ZXJEYXRhLnNob3J0RGVzY3JpcHRpb24sXG4gICAgICBrZXl3b3JkczogcGxheWVyRGF0YS5rZXl3b3JkcyxcbiAgICAgIHN1Z2dlc3Rpb246IHJlc3VsdC5zZWNvbmRhcnlSZXN1bHRzLnNlY29uZGFyeVJlc3VsdHMucmVzdWx0c1xuICAgICAgICAuZmlsdGVyKCh5KSA9PiB5Lmhhc093blByb3BlcnR5KFwiY29tcGFjdFZpZGVvUmVuZGVyZXJcIikpXG4gICAgICAgIC5tYXAoKHgpID0+IGNvbXBhY3RWaWRlb1JlbmRlcmVyKHgpKVxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVqZWN0KGV4KTtcbiAgfVxufTtcblxuY29uc3QgVmlkZW9SZW5kZXIgPSAoanNvbikgPT4ge1xuICB0cnkge1xuICAgIGlmIChqc29uICYmIChqc29uLnZpZGVvUmVuZGVyZXIgfHwganNvbi5wbGF5bGlzdFZpZGVvUmVuZGVyZXIpKSB7XG4gICAgICBsZXQgdmlkZW9SZW5kZXJlciA9IG51bGw7XG4gICAgICBpZiAoanNvbi52aWRlb1JlbmRlcmVyKSB7XG4gICAgICAgIHZpZGVvUmVuZGVyZXIgPSBqc29uLnZpZGVvUmVuZGVyZXI7XG4gICAgICB9IGVsc2UgaWYgKGpzb24ucGxheWxpc3RWaWRlb1JlbmRlcmVyKSB7XG4gICAgICAgIHZpZGVvUmVuZGVyZXIgPSBqc29uLnBsYXlsaXN0VmlkZW9SZW5kZXJlcjtcbiAgICAgIH1cbiAgICAgIHZhciBpc0xpdmUgPSBmYWxzZTtcbiAgICAgIGlmIChcbiAgICAgICAgdmlkZW9SZW5kZXJlci5iYWRnZXMgJiZcbiAgICAgICAgdmlkZW9SZW5kZXJlci5iYWRnZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICB2aWRlb1JlbmRlcmVyLmJhZGdlc1swXS5tZXRhZGF0YUJhZGdlUmVuZGVyZXIgJiZcbiAgICAgICAgdmlkZW9SZW5kZXJlci5iYWRnZXNbMF0ubWV0YWRhdGFCYWRnZVJlbmRlcmVyLnN0eWxlID09XG4gICAgICAgICAgXCJCQURHRV9TVFlMRV9UWVBFX0xJVkVfTk9XXCJcbiAgICAgICkge1xuICAgICAgICBpc0xpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZpZGVvUmVuZGVyZXIudGh1bWJuYWlsT3ZlcmxheXMpIHtcbiAgICAgICAgdmlkZW9SZW5kZXJlci50aHVtYm5haWxPdmVybGF5cy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXRlbS50aHVtYm5haWxPdmVybGF5VGltZVN0YXR1c1JlbmRlcmVyICYmXG4gICAgICAgICAgICBpdGVtLnRodW1ibmFpbE92ZXJsYXlUaW1lU3RhdHVzUmVuZGVyZXIuc3R5bGUgJiZcbiAgICAgICAgICAgIGl0ZW0udGh1bWJuYWlsT3ZlcmxheVRpbWVTdGF0dXNSZW5kZXJlci5zdHlsZSA9PSBcIkxJVkVcIlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaXNMaXZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSB2aWRlb1JlbmRlcmVyLnZpZGVvSWQ7XG4gICAgICBjb25zdCB0aHVtYm5haWwgPSB2aWRlb1JlbmRlcmVyLnRodW1ibmFpbDtcbiAgICAgIGNvbnN0IHRpdGxlID0gdmlkZW9SZW5kZXJlci50aXRsZS5ydW5zWzBdLnRleHQ7XG4gICAgICBjb25zdCBzaG9ydEJ5bGluZVRleHQgPSB2aWRlb1JlbmRlcmVyLnNob3J0QnlsaW5lVGV4dFxuICAgICAgICA/IHZpZGVvUmVuZGVyZXIuc2hvcnRCeWxpbmVUZXh0XG4gICAgICAgIDogXCJcIjtcbiAgICAgIGNvbnN0IGxlbmd0aFRleHQgPSB2aWRlb1JlbmRlcmVyLmxlbmd0aFRleHRcbiAgICAgICAgPyB2aWRlb1JlbmRlcmVyLmxlbmd0aFRleHRcbiAgICAgICAgOiBcIlwiO1xuICAgICAgY29uc3QgY2hhbm5lbFRpdGxlID1cbiAgICAgICAgdmlkZW9SZW5kZXJlci5vd25lclRleHQgJiYgdmlkZW9SZW5kZXJlci5vd25lclRleHQucnVuc1xuICAgICAgICAgID8gdmlkZW9SZW5kZXJlci5vd25lclRleHQucnVuc1swXS50ZXh0XG4gICAgICAgICAgOiBcIlwiO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgICAgdGh1bWJuYWlsLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgY2hhbm5lbFRpdGxlLFxuICAgICAgICBzaG9ydEJ5bGluZVRleHQsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoVGV4dCxcbiAgICAgICAgaXNMaXZlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9IGNhdGNoIChleCkge1xuICAgIHRocm93IGV4O1xuICB9XG59O1xuXG5jb25zdCBjb21wYWN0VmlkZW9SZW5kZXJlciA9IChqc29uKSA9PiB7XG4gIGNvbnN0IGNvbXBhY3RWaWRlb1JlbmRlcmVySnNvbiA9IGpzb24uY29tcGFjdFZpZGVvUmVuZGVyZXI7XG5cbiAgdmFyIGlzTGl2ZSA9IGZhbHNlO1xuICBpZiAoXG4gICAgY29tcGFjdFZpZGVvUmVuZGVyZXJKc29uLmJhZGdlcyAmJlxuICAgIGNvbXBhY3RWaWRlb1JlbmRlcmVySnNvbi5iYWRnZXMubGVuZ3RoID4gMCAmJlxuICAgIGNvbXBhY3RWaWRlb1JlbmRlcmVySnNvbi5iYWRnZXNbMF0ubWV0YWRhdGFCYWRnZVJlbmRlcmVyICYmXG4gICAgY29tcGFjdFZpZGVvUmVuZGVyZXJKc29uLmJhZGdlc1swXS5tZXRhZGF0YUJhZGdlUmVuZGVyZXIuc3R5bGUgPT1cbiAgICAgIFwiQkFER0VfU1RZTEVfVFlQRV9MSVZFX05PV1wiXG4gICkge1xuICAgIGlzTGl2ZSA9IHRydWU7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlkOiBjb21wYWN0VmlkZW9SZW5kZXJlckpzb24udmlkZW9JZCxcbiAgICB0eXBlOiBcInZpZGVvXCIsXG4gICAgdGh1bWJuYWlsOiBjb21wYWN0VmlkZW9SZW5kZXJlckpzb24udGh1bWJuYWlsLnRodW1ibmFpbHMsXG4gICAgdGl0bGU6IGNvbXBhY3RWaWRlb1JlbmRlcmVySnNvbi50aXRsZS5zaW1wbGVUZXh0LFxuICAgIGNoYW5uZWxUaXRsZTogY29tcGFjdFZpZGVvUmVuZGVyZXJKc29uLnNob3J0QnlsaW5lVGV4dC5ydW5zWzBdLnRleHQsXG4gICAgc2hvcnRCeWxpbmVUZXh0OiBjb21wYWN0VmlkZW9SZW5kZXJlckpzb24uc2hvcnRCeWxpbmVUZXh0LnJ1bnNbMF0udGV4dCxcbiAgICBsZW5ndGg6IGNvbXBhY3RWaWRlb1JlbmRlcmVySnNvbi5sZW5ndGhUZXh0LFxuICAgIGlzTGl2ZVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgR2V0U2hvcnRWaWRlbyA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgcGFnZSA9IGF3YWl0IEdldFlvdXR1YmVJbml0RGF0YSh5b3V0dWJlRW5kcG9pbnQpO1xuICBjb25zdCBzaG9ydFJlc3VsdCA9XG4gICAgYXdhaXQgcGFnZS5pbml0ZGF0YS5jb250ZW50cy50d29Db2x1bW5Ccm93c2VSZXN1bHRzUmVuZGVyZXIudGFic1swXS50YWJSZW5kZXJlci5jb250ZW50LnJpY2hHcmlkUmVuZGVyZXIuY29udGVudHNcbiAgICAgIC5maWx0ZXIoKHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHgucmljaFNlY3Rpb25SZW5kZXJlcjtcbiAgICAgIH0pXG4gICAgICAubWFwKCh6KSA9PiB6LnJpY2hTZWN0aW9uUmVuZGVyZXIuY29udGVudClcbiAgICAgIC5maWx0ZXIoKHkpID0+IHkucmljaFNoZWxmUmVuZGVyZXIpXG4gICAgICAubWFwKCh1KSA9PiB1LnJpY2hTaGVsZlJlbmRlcmVyKVxuICAgICAgLmZpbmQoKGkpID0+IGkudGl0bGUucnVuc1swXS50ZXh0ID09IFwiU2hvcnRzXCIpO1xuICBjb25zdCByZXMgPSBhd2FpdCBzaG9ydFJlc3VsdC5jb250ZW50c1xuICAgIC5tYXAoKHopID0+IHoucmljaEl0ZW1SZW5kZXJlcilcbiAgICAubWFwKCh5KSA9PiB5LmNvbnRlbnQucmVlbEl0ZW1SZW5kZXJlcik7XG4gIHJldHVybiBhd2FpdCByZXMubWFwKChqc29uKSA9PiAoe1xuICAgIGlkOiBqc29uLnZpZGVvSWQsXG4gICAgdHlwZTogXCJyZWVsXCIsXG4gICAgdGh1bWJuYWlsOiBqc29uLnRodW1ibmFpbC50aHVtYm5haWxzWzBdLFxuICAgIHRpdGxlOiBqc29uLmhlYWRsaW5lLnNpbXBsZVRleHQsXG4gICAgaW5saW5lUGxheWJhY2tFbmRwb2ludDoganNvbi5pbmxpbmVQbGF5YmFja0VuZHBvaW50IHx8IHt9XG4gIH0pKTtcbn07XG5cbmV4cG9ydHMuR2V0TGlzdEJ5S2V5d29yZCA9IEdldERhdGE7XG5leHBvcnRzLk5leHRQYWdlID0gbmV4dFBhZ2U7XG5leHBvcnRzLkdldFBsYXlsaXN0RGF0YSA9IEdldFBsYXlsaXN0RGF0YTtcbmV4cG9ydHMuR2V0U3VnZ2VzdERhdGEgPSBHZXRTdWdnZXN0RGF0YTtcbmV4cG9ydHMuR2V0Q2hhbm5lbEJ5SWQgPSBHZXRDaGFubmVsQnlJZDtcbmV4cG9ydHMuR2V0VmlkZW9EZXRhaWxzID0gR2V0VmlkZW9EZXRhaWxzO1xuZXhwb3J0cy5HZXRTaG9ydFZpZGVvID0gR2V0U2hvcnRWaWRlbztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/youtube-search-api/index.js\n");

/***/ })

};
;